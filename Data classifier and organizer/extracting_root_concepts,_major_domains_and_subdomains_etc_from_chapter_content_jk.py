# -*- coding: utf-8 -*-
"""extracting root concepts, major domains and subdomains etc from chapter content - JK

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1aeKfhDLOSxIwglA-X-ZrExvXQKbjIPEW
"""

!pip install llama-index -q
import pandas as pd
import numpy as np

chapter = '''
In computer science, an array is a data structure consisting of a collection of elements (values or variables), of same memory size, each identified by at least one array index or key. An array is stored such that the position of each element can be computed from its index tuple by a mathematical formula.[1][2][3] The simplest type of data structure is a linear array, also called a one-dimensional array.

For example, an array of ten 32-bit (4-byte) integer variables, with indices 0 through 9, may be stored as ten words at memory addresses 2000, 2004, 2008, ..., 2036, (in hexadecimal: 0x7D0, 0x7D4, 0x7D8, ..., 0x7F4) so that the element with index i has the address 2000 + (i × 4).[4] The memory address of the first element of an array is called first address, foundation address, or base address.

Because the mathematical concept of a matrix can be represented as a two-dimensional grid, two-dimensional arrays are also sometimes called "matrices". In some cases the term "vector" is used in computing to refer to an array, although tuples rather than vectors are the more mathematically correct equivalent. Tables are often implemented in the form of arrays, especially lookup tables; the word "table" is sometimes used as a synonym of array.

Arrays are among the oldest and most important data structures, and are used by almost every program. They are also used to implement many other data structures, such as lists and strings. They effectively exploit the addressing logic of computers. In most modern computers and many external storage devices, the memory is a one-dimensional array of words, whose indices are their addresses. Processors, especially vector processors, are often optimized for array operations.

Arrays are useful mostly because the element indices can be computed at run time. Among other things, this feature allows a single iterative statement to process arbitrarily many elements of an array. For that reason, the elements of an array data structure are required to have the same size and should use the same data representation. The set of valid index tuples and the addresses of the elements (and hence the element addressing formula) are usually,[3][5] but not always,[2] fixed while the array is in use.

The term "array" may also refer to an array data type, a kind of data type provided by most high-level programming languages that consists of a collection of values or variables that can be selected by one or more indices computed at run-time. Array types are often implemented by array structures; however, in some languages they may be implemented by hash tables, linked lists, search trees, or other data structures.

The term is also used, especially in the description of algorithms, to mean associative array or "abstract array", a theoretical computer science model (an abstract data type or ADT) intended to capture the essential properties of arrays.

'''

# chapter = '''In computer science, a linked list is a linear collection of data elements whose order is not given by their physical placement in memory. Instead, each element points to the next. It is a data structure consisting of a collection of nodes which together represent a sequence. In its most basic form, each node contains data, and a reference (in other words, a link) to the next node in the sequence. This structure allows for efficient insertion or removal of elements from any position in the sequence during iteration. More complex variants add additional links, allowing more efficient insertion or removal of nodes at arbitrary positions. A drawback of linked lists is that data access time is linear in respect to the number of nodes in the list. Because nodes are serially linked, accessing any node requires that the prior node be accessed beforehand (which introduces difficulties in pipelining). Faster access, such as random access, is not feasible. Arrays have better cache locality compared to linked lists.

# Linked lists are among the simplest and most common data structures. They can be used to implement several other common abstract data types, including lists, stacks, queues, associative arrays, and S-expressions, though it is not uncommon to implement those data structures directly without using a linked list as the basis.

# The principal benefit of a linked list over a conventional array is that the list elements can be easily inserted or removed without reallocation or reorganization of the entire structure because the data items do not need to be stored contiguously in memory or on disk, while restructuring an array at run-time is a much more expensive operation. Linked lists allow insertion and removal of nodes at any point in the list, and allow doing so with a constant number of operations by keeping the link previous to the link being added or removed in memory during list traversal.

# On the other hand, since simple linked lists by themselves do not allow random access to the data or any form of efficient indexing, many basic operations—such as obtaining the last node of the list, finding a node that contains a given datum, or locating the place where a new node should be inserted—may require iterating through most or all of the list elements.
# '''
######################################
definitions = '''
Here is a thought: ### Ontology creation prompt ###
Objective: Develop Root Concept, Major Domains, Sub Domains, Concepts, Attributes and Relationships, and Formal Representations for the subject covering the list of concepts provided herewith as an ontology.
### Definitions ###
1. Root Concept: The fundamental idea or principle that serves as the foundation for the text's subject matter. It encapsulates the core theme or overarching idea.
2. Major Domains: Broad areas of knowledge or fields that encompass multiple related topics or subjects. These domains provide a framework for organizing concepts within the root concept.
3. Sub Domains: More specific areas within major domains that further refine the focus. Sub domains represent narrower categories that contribute to a deeper understanding of the major domain.
4. Concepts: Individual ideas or phenomena that are part of a sub domain. Concepts represent specific instances, theories, or practices related to the subject matter.
5. Attributes and connections: Characteristics or properties that describe a concept. Attributes provide additional detail and context, helping to define the concept more clearly. Connections or interactions between concepts, attributes, and other entities. Relationships illustrate how different elements relate to one another within the context of the root concept.
6. Formal Representations: Structured ways of depicting concepts, attributes, and relationships, such as models, diagrams, or frameworks. These representations help visualize the connections and hierarchies within the subject matter.

'''

## prompt call
import requests

API_URL = "https://api-inference.huggingface.co/models/microsoft/Phi-3.5-mini-instruct"
headers = {
    "Authorization": "Bearer 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",
    "Content-Type": "application/json",
    "x-wait-for-model": "true"
}

def query(payload):
	response = requests.post(API_URL, headers=headers, json=payload)
	return response.json()
json_example = """{
        "root_concept": str,
        "major_domains": List[str],
        "sub_domains": List[str],
        "concepts": List[str],
        "Attributes and connections": Dict[str, List[str]],
        "formal_representations": Dict[str, List[str]],
    })"""
output = query({
    "inputs": f"""Read the {chapter} and find me the following out of it: Root concept, major domain, sub domains, concepts, Attributes and Connections, Formal representations. The definition for each is given here: {definitions}. Your output should be a JSON, with each variable being the key and the content corresponding to it as its value.


    ###Incentives###
    You will receive a tip of $$$ for correct description.
    You will be penalized if you fail to follow instructions or guidance

    ####JSON structure####:
    {json_example}

    ####Instructions####:
    Your output must be unambiguous. DO NOT EXPLAIN.
    Extracted JSON:
    """,
    "parameters": {"max_new_tokens": 600, "temperature":0.1}
})
# print(output[0]["generated_text"].split("You will be penalized if you fail to follow instructions or guidance")[1])

print(output)

print(output[0]["generated_text"].split("Extracted JSON:")[1])

import re
x = output[0]["generated_text"].split("Extracted JSON:")[1].split("###")[0].strip()
cleaned_response = re.sub(r'\s+', ' ', x)
cleaned_response = cleaned_response.replace("'", '"')
match_regex = re.search(r'(\{.*"formal_representations".*?\})', cleaned_response, re.DOTALL)
cleaned_response = repr(cleaned_response)[1:-1]

print(x)

if match_regex:
    filtered_json = match_regex.group(1)
    try:
        # Step 4: Parse and pretty print the cleaned JSON string
        data = json.loads(cleaned_response)
        print(json.dumps(data, indent=4))  # Print the extracted and cleaned JSON data
    except json.JSONDecodeError as e:
        print(f"Error decoding JSON: {e}")
else:
    print("No valid JSON found before 'formal_representations'")

"""## Output Structuring using Llama Index"""

# import json

hf_inference_response = output[0]
# data = json.dumps(hf_inference_response)
# data = json.loads(data)
data

from llama_index.prompts import QuestionTemplate

template = QuestionTemplate(
    f"Given the following text: {data}, extract the root concept, major domains, subdomains, and attributes."
)

from typing import List
from pydantic import BaseModel, Field
output = await sllm.achat([input_msg])
# get actual object
output_obj = output.raw
print(str(output))

# Here is a thought: ### Ontology creation prompt ###
# Objective: Develop Root Concept, Major Domains, Sub Domains, Concepts, Attributes and Relationships, and Formal Representations for the subject covering the list of concepts provided herewith as an ontology.
# ### Definitions ###
# 1. Root Concept: The fundamental idea or principle that serves as the foundation for the text's subject matter. It encapsulates the core theme or overarching idea.
# 2. Major Domains: Broad areas of knowledge or fields that encompass multiple related topics or subjects. These domains provide a framework for organizing concepts within the root concept.
# 3. Sub Domains: More specific areas within major domains that further refine the focus. Sub domains represent narrower categories that contribute to a deeper understanding of the major domain.
# 4. Concepts: Individual ideas or phenomena that are part of a sub domain. Concepts represent specific instances, theories, or practices related to the subject matter.
# 5. Attributes and connections: Characteristics or properties that describe a concept. Attributes provide additional detail and context, helping to define the concept more clearly. Connections or interactions between concepts, attributes, and other entities. Relationships illustrate how different elements relate to one another within the context of the root concept.
# 6. Formal Representations: Structured ways of depicting concepts, attributes, and relationships, such as models, diagrams, or frameworks. These representations help visualize the connections and hierarchies within the subject matter.

list_of_json = [
    {
        "chapter_name": "Linked List",
        "chapter_section": "Singly Linked List",
        "paragraph_number": "1",
        "paragraph_category": "introduction",
        "paragraph_content": "Introduction to singly linked lists and their basic structure."
    },
    {
        "chapter_name": "Linked List",
        "chapter_section": "Singly Linked List",
        "paragraph_number": "2",
        "paragraph_category": "definition",
        "paragraph_content": "A singly linked list is a data structure where each node points to the next node."
    },
    {
        "chapter_name": "Linked List",
        "chapter_section": "Doubly Linked List",
        "paragraph_number": "3",
        "paragraph_category": "table",
        "paragraph_content": "Comparison between singly and doubly linked lists."
    },
    {
        "chapter_name": "Linked List",
        "chapter_section": "Doubly Linked List",
        "paragraph_number": "4",
        "paragraph_category": "code_example",
        "paragraph_content": "Code to implement a doubly linked list."
    },
    {
        "chapter_name": "Linked List",
        "chapter_section": "Doubly Linked List",
        "paragraph_number": "5",
        "paragraph_category": "summary",
        "paragraph_content": "Summary of doubly linked list properties and operations."
    }
]
df = pd.DataFrame(list_of_json)
df

df = df.set_index(['chapter_section', 'paragraph_category'])
df

df_reset = df.reset_index()
df_reset['depth_levels'] = df_reset.index.nlevels
df_reset['depth_levels'] = [1, 2, 1, 3, 1]
df_reset

from huggingface_hub import InferenceClient

client = InferenceClient(
    "microsoft/Phi-3.5-mini-instruct",
    token="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",
)

# client.text_classification("Today is a great day")